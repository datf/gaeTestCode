{% extends "base.html" %}
{% block title %}Main{% endblock %}
{% block head %}
    {{ super() }}
    <script src='/_ah/channel/jsapi'></script>
{% endblock %}
{% block content %}
    <h1>Conveyor Machine</h1>
    <div class='row'>
        <div class='col-lg-12'>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Last Machine Time</th>
                <th>Time Since Last Reset</th>
                <th>Weight Moved</th>
                <th>Weight Move Rate (lbs / sec)</th>
                <th>Last Know Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span id="last-machine-time"></span></td>
                <td><span id="time-since-last-reset"></span></td>
                <td><span id="weight-moved"></span></td>
                <td><span id="weight-move-rate"></span></td>
                <td><span id="last-status"></span></td>
              </tr>
            </tbody>
          </table>
        </div>
    </div>
    <div class='row'>
        <div class="col-lg-8">
            <div id="flotchart" style="width:600px; height: 300px">
            </div>
        </div>
        <div class="col-lg-4">
            <button id="btn-reset" type="button" class="btn-lg btn-danger">
                Reset Counter
            </button>
        </div>
    </div>
{% endblock %}
{% block scripts %}
  {{ super() }}
  <script src="js/jquery.flot.min.js"></script>
  <script src="js/jquery.flot.time.min.js"></script>
  <script>
      function plotData()
      {
          if (data_plotted.length <= 0)
              return;
          now = new Date();
          a_minute_ago = new Date();
          a_minute_ago.setMinutes(now.getMinutes() - 1);
          a_minute_ago = a_minute_ago.getTime();
          options['xaxis']['min'] = a_minute_ago;
          options['xaxis']['max'] = now.getTime();
          while (data_plotted.length > 1 && data_plotted[1][0] < a_minute_ago)
          {
              data_plotted.shift();
          }
          updateTimeSinceLastReset();
          $.plot($flotchart, [data_plotted], options);
      }
  </script>
  <script>
    var user_token = '{{ user_token }}';
    var last_state;
    var data_plotted = [];
    var connected;
    var $flotchart = $('#flotchart');
    var plot_interval = setInterval(plotData, 500);
    var time_sync = 0;
    var options = {
          'lines': {'show': 'true'},
          'points': {'show': 'true'},
          'clickable': true,
          'hoverable': true
      }
    getSecondsSinceLastReset = function() {
        if (!last_state)
            return;
        var now = new Date();
        var last_reset = new Date(last_state.last_reset.timestamp);
        var elapsed = (now.getTime() - last_reset.getTime() - time_sync) / 1000;
        return Math.floor(elapsed);
    }
    getTwoDigits = function(num) {
        return num.toLocaleString('en', {minimumIntegerDigits:2});
    }
    updateTimeSinceLastReset = function() {
        var since_last_reset = getSecondsSinceLastReset();
        var sec = since_last_reset % 60;
        var min = Math.floor(since_last_reset / 60 % 60);
        var hr = Math.floor(since_last_reset / 60 / 60 % 60);
        var txt_elapsed = getTwoDigits(sec) + ' seconds';
        if (hr > 0)
        {
            txt_elapsed = hr + ':' + getTwoDigits(min) + ':' + getTwoDigits(sec);
        }
        else if (min > 0)
        {
            txt_elapsed = getTwoDigits(min) + ' minutes, ' + txt_elapsed;
        }

        $('#time-since-last-reset').html(txt_elapsed);
    }
    updateStats = function(data) {
        var lasttime = new Date(data.last_data.timestamp).toString();
        $('#last-machine-time').html(lasttime);
        $('#last-status').html(data.last_data.status);
        if (data.last_reset && data.last_reset.timestamp)
        {
            weigth_moved = data.last_data.current_total_weight
                - data.last_reset.current_total_weight;
            $('#weight-moved').html(
                            weigth_moved.toLocaleString()
                            );
            var since_last_reset = getSecondsSinceLastReset();
            $('#weight-move-rate').html(
                            (weigth_moved / since_last_reset).toLocaleString()
                            );
        }
    }
    onMessage = function(m) {
      var data = JSON.parse(m.data);
      var now_sync = new Date();
      var srv_sync = new Date(data.now);
      time_sync = now_sync.getTime() - srv_sync.getTime();
      updateStats(data);
      var timestamp_date = new Date(data.last_data.timestamp)
      var timestamp = timestamp_date.getTime();
      var current_weight = parseFloat(data.last_data.current_total_weight);
      if (!last_state)
      {
          options['xaxis'] = {
              mode: 'time',
              minTickSize: [10, 'second'],
          }
          last_state = data;
      }
      data_plotted.push([timestamp + time_sync,
                    current_weight - last_state.last_data.current_total_weight]
                    );
      last_state = data;
    }
    sendMessage = function(path, opt_param) {
      path += '?user_token=' + user_token;
      jQuery.post(path, opt_param);
    };

    onOpened = function() {
      connected = true;
      sendMessage('opened');
      console.log('opened!!!')
      //updateBoard();
    };
    onError = function(args) {
        // Usually the errors are caused by the channel timing out (as it has a
        // live of 2 hours, or the server being restarted, so waiting a few
        // seconds to reload the page...
        setTimeout('location.reload()', 5000);
    }
    onClose = function() {
        console.log('Connection closed');
        connected = false;
        clearInterval(plot_interval);
    }
    var channel = new goog.appengine.Channel('{{ token }}');
    var socket = channel.open();
    socket.onopen = onOpened;
    socket.onmessage = onMessage;
    socket.onerror = onError;
    socket.onclose = onClose;
    $('#btn-reset').click(function(){sendMessage('opened', 'reset=1')});
  </script>
{% endblock %}
