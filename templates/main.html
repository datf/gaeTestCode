{% extends "base.html" %}
{% block title %}Main{% endblock %}
{% block head %}
    {{ super() }}
    <script src='/_ah/channel/jsapi'></script>
{% endblock %}
{% block content %}
    <h1>Index</h1>
    <div class='row'>
        <div class='col-lg-12'>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Last Machine Time</th>
                <th>Time Since Last Reset</th>
                <th>Weight Moved</th>
                <th>Weight Move Rate (lbs / sec)</th>
                <th>Last Know Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span id="last-machine-time"></span></td>
                <td><span id="time-since-last-reset"></span></td>
                <td><span id="weight-moved"></span></td>
                <td><span id="weight-move-rate"></span></td>
                <td><span id="last-status"></span></td>
              </tr>
            </tbody>
          </table>
        </div>
    </div>
    <div class='row'>
        <div class="col-lg-8">
            <div id="flotchart" style="width:600px; height: 300px">
            </div>
        </div>
        <div class="col-lg-4">
            <button id="btn-reset" type="button" class="btn-lg btn-danger">
                Reset
            </button>
        </div>
    </div>
{% endblock %}
{% block scripts %}
  {{ super() }}
  <script src="js/jquery.flot.min.js"></script>
  <script src="js/jquery.flot.time.min.js"></script>
  <script>
      function plotData()
      {
          if (data_plotted.length <= 0)
              return;
          now = new Date();
          a_minute_ago = new Date()
          a_minute_ago.setMinutes(now.getMinutes() - 1)
          a_minute_ago = a_minute_ago.getTime()
          options['xaxis']['min'] = a_minute_ago
          options['xaxis']['max'] = now.getTime() + 3000
          while (data_plotted.length > 1 && data_plotted[1][0] < a_minute_ago)
          {
              data_plotted.shift();
          }
          $.plot($flotchart, [data_plotted], options);
      }
  </script>
  <script>
    var user_token = '{{ user_token }}';
    var last_state;
    var data_plotted = [];
    var connected;
    var $flotchart = $('#flotchart');
    var plot_interval = setInterval(plotData, 500);
    var options = {
          'lines': {'show': 'true'},
          'points': {'show': 'true'},
          'clickable': true,
          'hoverable': true
      }
    updateStats = function(data) {
        console.log('updating stats');
        var lasttime = new Date(data.last_data.timestamp).toString();
        $('#last-machine-time').html(lasttime);
        $('#last-status').html(data.last_data.status);
        if (data.last_reset && data.last_reset.timestamp)
        {
            var now = new Date();
            console.log(data.last_reset);
            var last_reset = new Date(data.last_reset.timestamp);
            var elapsed = (now.getTime() - last_reset.getTime()) / 1000;
            var txt_elapsed = Math.floor(elapsed) + ' seconds';
            $('#time-since-last-reset').html(txt_elapsed);
            weigth_moved = data.last_data.current_total_weight
                - data.last_reset.current_total_weight;
            $('#weight-moved').html(weigth_moved);
            $('#weight-move-rate').html(weigth_moved / elapsed);
        }
    }
    onMessage = function(m) {
      data = JSON.parse(m.data);
      updateStats(data);
      var timestamp_date = new Date(data.last_data.timestamp)
      var timestamp = timestamp_date.getTime();
      var current_weight = parseFloat(data.last_data.current_total_weight);
      if (!last_state)
      {
          options['xaxis'] = {
              mode: 'time',
              minTickSize: [10, 'second'],
          }
          last_state = data;
      }
      data_plotted.push([timestamp,
                    current_weight - last_state.last_data.current_total_weight]
                    );
      last_state = data;
    }
    sendMessage = function(path, opt_param) {
      path += '?user_token=' + user_token;
      jQuery.post(path, opt_param);
    };

    onOpened = function() {
      connected = true;
      sendMessage('opened');
      console.log('opened!!!')
      //updateBoard();
    };
    onError = function(args) {
        // Usually the errors are caused by the channel timing out (as it has a
        // live of 2 hours, or the server being restarted, so waiting a few
        // seconds to reload the page...
        setTimeout('location.reload()', 5000);
    }
    onClose = function() {
        console.log('Connection closed');
        connected = false;
        clearInterval(plot_interval);
    }
    var channel = new goog.appengine.Channel('{{ token }}');
    var socket = channel.open();
    socket.onopen = onOpened;
    socket.onmessage = onMessage;
    socket.onerror = onError;
    socket.onclose = onClose;
    $('#btn-reset').click(function(){sendMessage('opened', 'reset=1')});
  </script>
{% endblock %}
